\documentclass[11pt,french]{article}
\usepackage[utf8]{inputenc}
\usepackage{titlesec}
\usepackage{hyperref}
\usepackage{babel}

% Sauter une page à chaque fin (ou début?) de section
\titleclass{\section}{top}
\newcommand\sectionbreak{\clearpage}

\title{Comment découvrir son corps ?}
\author{Lucas Schwab}
\date{Mars - Aout 2020}

\begin{document}

\maketitle

\tableofcontents

% % % SECTION % % %
\section{Remerciements}

% % % SECTION % % %
\section{Introduction}

Afin de contrôler un robot de manière intuitive, donc en lui donnant un position comme but et non une posture (comme une suite d'angle pour le robot Poppy Ergo Jr), nous avons besoin d'un modèle inverse. Celui-ci peut rapidement devenir difficile à construire selon la complexité du robot. Le but de ce stage est de trouver une manière simple de générer un modèle inverse fiable.\\
J'utilise une base de donnée contenant une posture et la position de l'effecteur du robot. La méthode utilisé pour obtenir le modèle inverse consiste à rechercher une liste des points dans cette base les plus proche du but demandé, et de donner en résultat la moyenne des postures associées à ces points pondéré par leurs distance au but. Le contenu de cette base est donc important pour avoir un résultat convaincant. L'apprentissage utilisé pour construire et remplir cette base de donnée repose sur deux méthodes:
\begin{itemize}
    \item \textbf{Motor Babling} ou babillage moteur, qui consiste à donner une posture aléatoire au robot et d'observer l'effect que cela produit. Pour ce projet cela se résume à créer une liste d'angles aléatoires pour la posture, et de calculer la position de l'effecteur du robot. Cette méthode permet déjà de remplir la base de donnée pour un robot simple, comme un bras ne possédant que 2 ou 3 jointure. Mais ces points ne remplissent pas tout l'espace de travail du robot lorsque la complexité de celui-ci robot augmente. S'il y a plus de jonctions, il y a aussi plus de chance que le robot soit replié sur lui même.
    \item \textbf{Goal Babling} Le babillage moteur est une méthode simple qui ne remplis pas intelligemment l'espace. Une manière d'ajouter plus efficacement des points peut être le babillage par but. Pour éviter de ne visiter que les zones facilement atteignables nous cherchons à essayer d'atteindre un but. Le plus difficile à faire et la selection de ce but.
\end{itemize}

Les robots concernées par cet apprentissages sont principalements des bras robotiques, consitués d'une suite de sections rigides reliées par des moteurs qui peuvent prendre un certain angle comme position. Il serait possible d'adapter l'apprentissage pour une autre forme de robot, mais nous utilisons ici une représentation virtuelle du robot Poppy Ergo Jr.

% TODO Image du Poppy Ergo Jr %

% % % SECTION % % %
\section{Modèle inverse}

La première partie à mettre en place est le modèle inverse. Comme il suffit de séléctionner le point le plus proche dans la base de donnée, il faut mettre un place en Nearest-Neighbor. Celui-ci doit répondre à plusieurs contraintes:
\begin{itemize}
    \item La recherche d'un Nearest Neighbor doit être rapide : Utiliser une méthode naive qui calcule une à une la distance entre le but et tous les points de la base n'est pas envisagable, car dans l'execution de cet apprentissage, le modèle inverse est utilisé à chaque étape de "Goal Babling". Pour maximiser l'efficacité des résultats, un maximum d'étape de goal babling est à faire.
    \item L'ajout d'un point à la base de donnée doit être possible et rapide : Chaque étape de "Goal Babling" ajoute un point à la base du modèle inverse. Il faut donc que cet ajout soit faisable et si possible rapide.
\end{itemize}

Le programme est en python, et est basé sur \href{http://www.fabien.benureau.com/recode/benureau2015_gb/benureau2015_gb.html}{ce projet} ce projet qui utilise une bibliothèque appelé "learners". Celle-ci permet l'ajout d'un point dans la base, mais est difficile d'utilisation et, selon l'installation, peut ne pas être rapide.

Une autre bibliothèque assez utilisé pour le Nearest Neighbor est "Sklearn" avec la méthode du KDTree. Cette bibliothèque est assez facile d'utilisation et d'installation, est aussi rapide pour la recherche d'un Nearest Neighbor mais ne permet pas d'inserer facilement un point dans la base. En effect, le KDTree utilise une architecture d'arbre binaire pour ranger les points. Chaque noeud contient un point de la base est un hyper-plan qui coupe l'espace en deux, créant ainsi deux sous-espaces qui correspondent aux deux branches de ce noeud. Pour une utilisation rapide de cet arbre binaire, il est important de le garder équilibré. Ceci est facile à la création de l'arbre, mais cet équilibre est impossible à garantir lors de l'ajout d'un point sans procéder à un rééquilibrage total de l'arbre. C'est pourquoi Sklearn ne propose simplement pas cette méthode.

J'utilise donc une bibliothèque appellée "Rtree" qui utilise la méthode du RTree et est basé sur la librairie "libspatialindex" écrite en C. Le Rtree utilise des rectangles englobant, qui regroupe les points de la base en plusieurs paquets. La recherche d'un voisin proche est simplifié par la structure de l'arbre et donc rapide. Les données sont organisé spécialement pour le stockage sur disque comme une base de donnée.

% % % SECTION % % %
\section{Algorithmes utilisés}

Le modèle inverse ne change pas dans cet apprentissage. Il reste donc trois parties de l'apprentissage qu'il faut créer:
\begin{itemize}
    \item La génération aléatoire d'une posture dans l'étape de "Motor Babling".
    \item La génération d'un but dans l'étape de "Goal Babling".
    \item La modification de la posture retourné par le modèle inverse pour le but généré précédemment.
\end{itemize}

J'ai utilisé des valeurs aléatoires uniformes pour générer une posture dans le Motor Babling, et aussi une valeur aléatoire uniforme dans un petit interval pour modifier la posture donnée par le modèle inverse. Il reste la génération d'un but à faire, et il existe une multitude de manière de faire. La distribution finale de ces but doit remplir au maximum l'espace atteignable par le robot, sans pouvoir connaître cet espace. Voici les algorithme que j'ai mis en place dans ce projet.

\subsection{Agnostic goal generation}

La génération agnostique de but n'utilise aucun paramètre présumé sur le robot (comme sa taille). A chaque itération l'algorithme garde en mémoire les coordonnées maximales que peut atteindre le robot dans chacun des axes, et génère un point dans cet interval avec un facteur qui permet un peu d'exploration. Le résultat est ainsi une zone de génération de but très proche de la zone atteignable par le robot.

\subsection{Frontier strategy}

La génération agnostique donnera un volume en forme de pavé droit, et dans notre cas la zone atteignable par le robot ressemble plus à une sphère. C'est à cette problématique que répond la stratégie de frontière. Cette stratégie consiste à discrétiser l'espace en carré pour la 2D ou en cube pour la 3D pour determiner quelle cellule (carré / cube)  a déjà été visité et s'en servir pour la génération d'un nouveau but. Le nouveau but est généré avec une probabilité \emph{p} dans des cellules déjà visitées et avec une probabilité 1-\emph{p} dans une cellule non visitée.

Pour savoir quelle cellule non visitée est choisie, une position déjà atteinte par le robot est selectionnée aléatoirement. Ensuite, une direction est choisie aléatoirement. Cet algorithme va suivre le vecteur déterminé par la position et la direction, et va se déplacer dans l'espace jusqu'à atteindre une cellule qui n'a pas encore été visitée.

% % % SECTION % % %
\section{Evaluation des algorithmes}

Pour pouvoir comparer les résultats des différents apprentissages, il faut pouvoir donner une métrique pour mesurer ces résultats. Dans un premier temps il faut représenter un maximum de donnée à l'écran pour laisser l'utilisatuer juger si son algorithme fonctionne.

\subsection{Affichage}

La première étape de mon projet consiste à afficher une représentation du robot, pour pouvoir comparer certaines formes et tailles avant de me lancer dans la suite. Voici donc un exmple de robot dans une certaine posture. La principale bibliothèque d'affichage utilisée est OpenGL. J'ai aussi utilisé SDK pour la création de la fenêtre.

% TODO Afficher image du robot sur fond bland %

Ensuite, le résultat de mes algorithmes me retournent une liste de point. Cela n'a aucun sens de représenter tout le robot pour chacun de ces points, j'ai préféré ne représenter que le bout du robot (appelé End Point). Voici donc le résultat d'un motor babling après 5 000 étapes:

% TODO Afficher nuage de point, motor babling, 5 000 étapes

Cette représentation est très utile pour un environnement 2D, mais dans notre cas il est difficile d'évaluer la distance d'un point par rapport au centre. J'ai donc décider de colorer les points par rapport à leurs distances au centre:

% TODO Afficher un nuage de point coloré, mêmes données qu'au dessus

Enfin, le programme peut aussi trier et représenter les données dans un graphe. Voici par exemple une repartition des points en fonction de l'axe X, Y ou Z, mais aussi par rapport à la distance au centre (la base du robot, le point d'attache).

% TODO Afficher les graphes résultats par rapport aux données précédentes

Ces différents affichages ne permettent cependant pas de mesurer les résultats.

\subsection{Evaluation}

Il nous faut une métrique précise. Par exemple, une propriété voulue pourrait être la précision de notre modèle. Il est possible de mesurer par exemple la différence moyenne entre une position recherchée et la position retournée par le modèle inverse. 

\end{document}